\documentclass{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{bm}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{tikz}
\usepackage{hyperref}

\hypersetup{
    colorlinks,
    linkcolor={red!30!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}


\newcommand{\vct}[1]{\mathbf{#1}}
\newcommand{\vx}{\vct{x}}
\newcommand{\vy}{\vct{y}}
\newcommand{\Z}{\mathcal{Z}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\Ham}{\mathcal{H}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\var}{\mathrm{var}}
\newcommand{\com}{\mathrm{com}}

\newcommand{\llbra}{[\![}
\newcommand{\llket}{]\!]}

% annotation macros
\newcommand{\repl}[2]{{\color{gray} [#1] }{\color{blue} #2}}
\newcommand{\add}[1]{{\color{blue} #1}}
\newcommand{\del}[1]{{\color{gray} [#1]}}
\newcommand{\note}[1]{{\color{OliveGreen}\small [\textbf{Comment.} #1]}}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2
}


\begin{document}



\title{NAMD Hacking Notes}
\author{ \vspace{-10ex} }
\date{ \vspace{-10ex} }


\maketitle

\tableofcontents


\section{SimParameters}

Let us start with something easy--the input parameters.
%
The header file `SimParameters.h' effectively
lists every parameter we can use in the `.conf' configuration file.
%
For example,
\begin{lstlisting}
  Bool commOnly; // Don't do any force evaluations
  Bool tclForcesOn; // Are Tcl forces on?
  Bool colvarsOn;
\end{lstlisting}
%
These parameters are organized in a class,
and the instance \texttt{simParams}
(which is a nickname of \texttt{Node::Object()->simParameters})
is available in both master and slaves (see later),
which means that the input parameters are accessible
by the master and all slaves.


\section{Master/slave architecture}

NAMD is a parallel code of molecular dynamics (MD).
%
It means that there are different virtual ``workers''
do different jobs simultaneously.

Tasks that can be parallelized are done on the slaves.
%
For example, integrating Newton's equation, computing the force and energy, etc.

Tasks that are not parallelized are done on the master.
%
For example, reading the user input file,
writing the restart file, etc.

When the code is running, there are many slaves,
but only one master.
%
In NAMD, the notion `worker' is a virtual node,
and it does not match the number of CPU cores.
%
For example, you can run NAMD on a 16-core machine
for a large protein/water system;
NAMD may decide to use thousands of slaves
instead of 15 or 16 of them.

The real node can be accessed by \texttt{Node::Object()}.
%
For example, we can print out the node id and the number of nodes by
\begin{lstlisting}
CkPrintf("%d/%d\n",Node::Object()->myid(),Node::Object()->numNodes());
\end{lstlisting}


\subsection{Master-slave communication}

Because of the master/slave architecture,
we need some tools to communicate between master and slaves.
%
\begin{enumerate}
  \item \textbf{Collection.}
    Section \ref{sec:collection} shows how the slaves
    can send information to the master.

  \item \textbf{Reduction.}
    Section \ref{sec:reduction} shows how the master
    can get the sum of an additive quantity
    computed at slaves (called reduction).

  \item \textbf{Broadcast.}
    Section \ref{sec:broadcast} shows how the master
    can send information to the slaves.
\end{enumerate}
%


\section{Controller (master) and Sequencer (slave)}

`Controller.C' is the code running on the master.
`Sequencer.C' is the code running on the slaves.
For functions that require communication between
the master and slaves, e.g., \texttt{integrate()},
there is a version for the master,
and another version for the slaves.

\subsection{Controller}

The most important function is \texttt{integrate()},
which runs the main MD loop,
this function is independent of the function of the same name
in \texttt{Sequencer.C},
which is for the slaves.

\begin{lstlisting}
void Controller::integrate(int scriptTask) {
  for ( ++step ; step <= numberOfSteps; step++ ) {
    adaptTempUpdate(step);
    tcoupleVelocities(step);
    berendsenPressure(step);
    enqueueCollections(step);  // collect positions, velocities, forces
    receivePressure(step);
    if ( zeroMomentum && dofull && ! (step % slowFreq) )
      correctMomentum(step);
    ...
#if STEP_BARRIER
    cycleBarrier(1, step);
#endif
    rebalanceLoad(step);
  }
}
\end{lstlisting}
%
Now notice that the master does not actually
integrate Newton's equation of motion,
because it is a job of slaves.
%
All the master does is to collect data from slaves
and assist some tricky steps for the thermostat and barostat.
%
It also does the writing of restart files.
%
For example, for adaptive tempering,
it is done in \texttt{adaptTempUpdate(step)}.

The `Controller' has a few handy variables,
they are quite self explanatory.
\begin{lstlisting}
  NamdState *const state;
  BigReal totalEnergy;
  BigReal kineticEnergy;
  int     numDegFreedom;
  Tensor  pressure;
\end{lstlisting}
%
For example, \texttt{state->pdb} contains information
of the initial PDB, which can help determine the number of atoms
via \texttt{state->pdb->num\_atoms()}, or the position of the \texttt{i}th atom
via \texttt{state->pdb->get\_position\_for\_atom(pos, i)}.
Similarly, \texttt{state->molecule} contains information of charge and mass,
e.g., \texttt{state->molecule->atommass(i)} gives the mass
of the \texttt{i}th atom.

The data collection part is done by the function
\texttt{enqueueCollections()}.

\begin{lstlisting}
// collect positions, velocities, forces from slaves
void Controller::enqueueCollections(int timestep)
{
  if ( Output::coordinateNeeded(timestep) ){
    collection->enqueuePositions(timestep,state->lattice);
  }
  if ( Output::velocityNeeded(timestep) )
    collection->enqueueVelocities(timestep);
  if ( Output::forceNeeded(timestep) )
    collection->enqueueForces(timestep);
}
\end{lstlisting}


\subsection{Sequencer}

The slave version of function \texttt{integrate()}
is much more complex.  Below is a simplified version.

\begin{lstlisting}
void Sequencer::integrate(int scriptTask) {
  for ( ++step; step <= numberOfSteps; step++ ) {
    rescaleVelocities(step);
    tcoupleVelocities(timestep,step);
    berendsenPressure(step);

    if ( ! commOnly )
      addForceToMomentum(0.5*timestep);
    ...
    if ( ! commOnly ) addVelocityToPosition(0.5*timestep);
    ...
    langevinPiston(step);
    if ( ! commOnly ) addVelocityToPosition(0.5*timestep);
    ...
    submitHalfstep(step);
    ...
    runComputeObjects(!(step%stepsPerCycle),step<numberOfSteps);

    // reassignment based on full-step velocities
    if ( !commOnly && ( reassignFreq>0 ) && ! (step%reassignFreq) ) {
      reassignVelocities(timestep,step);
      addForceToMomentum(-0.5*timestep);
      rattle1(-timestep,0);
    }

    if ( ! commOnly ) {
      langevinVelocitiesBBK1(timestep);
      addForceToMomentum(timestep);
      langevinVelocitiesBBK2(timestep);
    }
    ...
    rattle1(timestep,1);
    ...
    submitHalfstep(step);
    if ( zeroMomentum && doFullElectrostatics ) submitMomentum(step);
    ...
    if ( ! commOnly ) {
      addForceToMomentum(-0.5*timestep);
    }
    ...
    submitReductions(step);
    submitCollections(step);
    adaptTempUpdate(step);
    ...
#if  STEP_BARRIER
    cycleBarrier(1, step);
#endif
    rebalanceLoad(step);
  }
}
\end{lstlisting}

Sequencer sends data to the Controller by

\begin{lstlisting}
void Sequencer::submitCollections(int step, int zeroVel)
{
  int prec = Output::coordinateNeeded(step);
  if ( prec ) // prec: 1 for float, 2 for double
    collection->submitPositions(step,patch->atom,patch->lattice,prec);
  if ( Output::velocityNeeded(step) )
    collection->submitVelocities(step,zeroVel,patch->atom);
  if ( Output::forceNeeded(step) )
    collection->submitForces(step,patch->atom,maxForceUsed,patch->f);
}
\end{lstlisting}




\section{\label{sec:collection}CollectionMaster (master) and CollectionMgr (slave)}


Collection is about send vectors, positions, velocities, forces
from slaves to the master.
%
We will focus on the non-\texttt{MEM\_OPT\_VERSION}, which is simpler.

\subsection{CollectionMaster}

The most important function is
\texttt{CollectionMaster::enqueuePositions()},
which is used in \texttt{Controller.C}.

\begin{lstlisting}
// this function is to be called by a slave node for the
// master to receive the coordinates
void CollectionMaster::receivePositions(CollectVectorMsg *msg)
{
  // the size is the total number of atoms in the system
  positions.submitData(msg,Node::Object()->molecule->numAtoms);
  delete msg;
  CollectVectorInstance *c;
  while ( ( c = positions.removeReady() ) ) { disposePositions(c); }
}

// keep requesting from slaves the coordinates in step `seq'
// use the coordinates (for file writing, TCL scripting, etc),
// and dispose of it
void CollectionMaster::enqueuePositions(int seq, Lattice &lattice)
{
  positions.enqueue(seq,lattice);
  CollectVectorInstance *c;
  while ( ( c = positions.removeReady() ) ) { disposePositions(c); }
}

// write and use the position saved in the
// CollectVectorInstance *c, and then delete it
void CollectionMaster::disposePositions(CollectVectorInstance *c)
{
  int seq = c->seq;
  int size = c->data.size();
  if ( ! size ) size = c->fdata.size();
  Vector *data = c->data.begin();
  FloatVector *fdata = c->fdata.begin();
  // write the coordinates to file
  Node::Object()->output->coordinate(seq,size,data,fdata,c->lattice);
  c->free();
}
\end{lstlisting}


\texttt{CollectVectorSequence} is an array
of \texttt{CollectVectorInstance}s at different time steps.
%
The array is organized as a queue (first in first out)
according to the time step--the first \texttt{CollectVectorInstance}
entering the queue is to be removed first.


\begin{lstlisting}
class CollectVectorSequence
{
  ResizeArray<CollectVectorInstance*> data;
  ResizeArray<int> queue; // queue of step sizes
  ResizeArray<Lattice> latqueue; // queue of lattices
  int blocked;
  CollectVectorSequence() : blocked(0) { ; }

  // this function is called when a slave node try to
  // send a message `msg' to the master, via
  //  CollectionMaster::receivePositions(msg);
  void submitData(CollectVectorMsg *msg, int max_index) {
    int seq = msg->seq;
    CollectVectorInstance **c = data.begin();
    CollectVectorInstance **c_e = data.end();
    for( ; c != c_e && (*c)->seq != seq; ++c )
      ;
    if ( c == c_e ) { // no match found
      c = data.begin();
      for( ; c != c_e && (*c)->notfree(); ++c )
        ;
      if ( c == c_e ) {
        data.add(new CollectVectorInstance(seq));
        c = data.end() - 1;
      }
      (*c)->reset(seq);
    }
    // absorb the message `msg' from the sending slave node
    (*c)->append(msg, max_index);
  }

  // add an entry for step `seq' to the `to-do' list
  void enqueue(int seq, Lattice &lattice) {
    queue.add(seq);
    latqueue.add(lattice);
  }

  // return a pointer to the CollectVectorInstance
  // that is in the queue and is just removed
  CollectVectorInstance* removeReady(void) {
    CollectVectorInstance *o = 0;
    if ( queue.size() && !blocked ) {
      // try to remove the first item in the queue
      int seq = queue[0];
      CollectVectorInstance **c = data.begin();
      CollectVectorInstance **c_e = data.end();
      for( ; c != c_e && (*c)->seq != seq; ++c )
        ;
      if ( c != c_e && (*c)->ready() ) { // all slaves are done
        // dump the first item from the queue
        o = *c;
        o->lattice = latqueue[0];
        queue.del(0,1);
        latqueue.del(0,1);
      }
    }
    return o;
  }
};

\end{lstlisting}





The \texttt{CollectVectorInstance} looks like this.

\begin{lstlisting}
class CollectVectorInstance
{
  int seq;
  Lattice lattice;
  ResizeArray<Vector> data;
  ResizeArray<FloatVector> fdata;
  int remaining;

  CollectVectorInstance(int s) { reset(s); }

  void reset(int s) {
    seq = s;
    remaining = (PatchMap::Object())->numNodesWithPatches();
  }

  // max_index is the maximal _global_ index
  void append(CollectVectorMsg *msg, int max_index) {
    AtomID *a = msg->aid;
    Vector *d = msg->data;
    FloatVector *fd = msg->fdata;
    int size = msg->aid_size;
    if ( msg->data_size ) { // double data
      data.resize(max_index);
      Vector *ptr = data.begin();
      for( int i = 0; i < size; ++i ) { ptr[a[i]] = d[i]; }
    }
    if ( msg->fdata_size ) { // float data
      fdata.resize(max_index);
      FloatVector *ptr = fdata.begin();
      for( int i = 0; i < size; ++i ) { ptr[a[i]] = fd[i]; }
    }
    --remaining;
  }

  // returns true if all slaves have done reporting
  int ready(void) { return (remaining == 0); }
};
\end{lstlisting}



\subsection{CollectionMgr}




The slave node version of submitPositions() basically
copies the coordinates and the global atom IDs to
a message, and then calls CollectionMaster to receive the message.
%
\begin{lstlisting}
void CollectionMgr::submitPositions(int seq, FullAtomList &a,
                                    Lattice l, int prec)
{
  int numAtoms = a.size();
  AtomIDList aid(numAtoms);
  PositionList d(numAtoms);
  for ( int i=0; i<numAtoms; ++i ) {
    aid[i] = a[i].id;
    d[i] = l.reverse_transform(a[i].position,a[i].transform);
  }
  CollectVectorInstance *c = positions.submitData(seq,aid,d,prec);
  if ( c != 0 ) { // all nodes have submitted data to `c'
    // copy the coordinates from `c' to `msg'
    int aid_size = c->aid.size();
    int data_size = c->data.size();
    int fdata_size = c->fdata.size();
    CollectVectorMsg *msg
      = new (aid_size, data_size, fdata_size,0) CollectVectorMsg;
    msg->seq = c->seq;
    msg->aid_size = aid_size;
    msg->data_size = data_size;
    msg->fdata_size = fdata_size;
    memcpy(msg->aid,c->aid.begin(),aid_size*sizeof(AtomID));
    memcpy(msg->data,c->data.begin(),data_size*sizeof(Vector));
    memcpy(msg->fdata,c->fdata.begin(),fdata_size*sizeof(FloatVector));

    // tell master to receive the message `msg'
    CProxy_CollectionMaster cm(master);
    cm.receivePositions(msg);
    c->free();
  }
}
\end{lstlisting}

Here \texttt{positions} is a \texttt{CollectVectorSequence},
which is a few \texttt{CollectVectorInstance}
at different time steps.
%
The class \texttt{CollectVectorSequence} serves
as a local buffer on the slave node for data
\emph{to be} sent to the master.
%
When the slave node want to send something
(array indices \texttt{i} and vectors \texttt{d})
of step \texttt{seq} to the master,
it calls the function \texttt{submitData(seq, i, d)}.
%
After the call, the data are not sent,
but cached on the local slave node.


\begin{lstlisting}
  class CollectVectorSequence
  {
    // array of CollectVectorInstance's
    ResizeArray<CollectVectorInstance*> data;

    // this function returns 1 if all slaves have submitted
    // the data for time step `seq'
    CollectVectorInstance* submitData(int seq, AtomIDList &i,
                                      ResizeArray<Vector> &d, int prec=2) {
      // find the CollectVectorInstance that matches the time step `seq'
      CollectVectorInstance **c = data.begin();
      CollectVectorInstance **c_e = data.end();
      for( ; c != c_e && (*c)->seq != seq; ++c )
        ;
      if ( c == c_e ) { // no match found
        c = data.begin();
        for( ; c != c_e && (*c)->notfree(); ++c )
          ;
        // append a new entry at the end of `data'
        if ( c == c_e ) {
          data.add(new CollectVectorInstance);
          c = data.end() - 1;
        }
        (*c)->reset(seq,prec);
      }
      // add the input indices and data `i' and `d' to `*c'
      // if all slaves have done the submission, then
      // the append() function returns 1
      if ( (*c)->append(i,d) ) {
        return *c; // all slaves have submitted
      } else {
        return 0; // not all slaves have submitted
      }
    }
  };
\end{lstlisting}

The class \texttt{CollectVectorInstance} looks like this.

\begin{lstlisting}
class CollectVectorInstance
{
  int seq; // time step
  AtomIDList aid; // array of global atom indices
  int precisions; // 1 for float, 2 for double
  ResizeArray<Vector> data;
  ResizeArray<FloatVector> fdata;
  int remaining;

  CollectVectorInstance(void) : seq(-10) { ; }

  // set the time step and precision
  void reset(int s, int p) {
    seq = s;
    precisions = p;
    remaining = PatchMap::Object()->numHomePatches();
    ...
  }

  // true -> send it and delete it!
  int append(AtomIDList &a, ResizeArray<Vector> &d) {
    int size = a.size();
    for( int i = 0; i < size; ++i ) {
      aid.add(a[i]);
      if ( precisions & 2 ) data.add(d[i]); // add as double
      if ( precisions & 1 ) fdata.add(d[i]); // add as float
    }
    return ( ! --remaining ); // return 1 if I'm the last slave node
  }
};
\end{lstlisting}


% (*c)->reset();   // slave node 1
% (*c)->append();   // slave node 2, remaining = 2
% (*c)->append();   // slave node 3, remaining = 1
% (*c)->append();   // slave node 1, remaining = 0

\section{\label{sec:reduction}ReductionMgr}

In most cases,
``reduction'' means adding things up.
%
For example, each slave node has computed
a part of the potential energy,
the total potential energy is the sum of them.
%
Then after a reduction,
the \emph{master} node gets the total potential.

A limitation is that the reduced thing
must be a \texttt{double} or \texttt{BigReal}.
%
For a vector, you need to do it for the three components.
%

If you need to reduce something new,
just add something in \texttt{ReductionMgr.h}.
\begin{lstlisting}
enum {
  ...
  REDUCTION_MY_QUANTITY,
  // semaphore (must be the last)
  REDUCTION_MAX_RESERVED
} ReductionTag;
\end{lstlisting}
%
Then in the code for slaves, e.g. \texttt{Sequence.C},
%
\begin{lstlisting}
  reduction->item(REDUCTION_MY_QUANTITY) += my_quantity;
\end{lstlisting}
%
and the master (e.g. \texttt{Controller.C}) can read the sum,
%
\begin{lstlisting}
  my_quantity = reduction->item(REDUCTION_MY_QUANTITY);
\end{lstlisting}


\section{\label{sec:broadcast}Broadcast}

``Broadcast'' means sending information from the master
to the slaves.
%
If we want to broadcast a \texttt{Vector} called \texttt{myvec1},
we modify \texttt{Broadcasts.h}
%
\begin{lstlisting}
enum {
  ...
  myvec1Tag,
  dummyTag
};

struct ControllerBroadcasts
{
  ...
  SimpleBroadcastObject<Vector> myvec1;
  ControllerBroadcasts(const LDObjHandle *ldObjPtr = 0) :
    ...
    myvec1(myvec1Tag, ldObjPtr),
    ...
  { ; }
};
\end{lstlisting}





\section{Output}

The \texttt{output->coordinate()} function is used to write coordinates.
%
This function is used in \texttt{CollectionMaster::disposePosition()}
defined in \texttt{CollectionMaster.C}.

\begin{lstlisting}
void Output::coordinate(timestep, n, Vector coor, FloatVector fcoor,
                        Lattice &lattice)
{
  // Output to DCD trajectory use the float coordinates
  if ( timestep % simParam->dcdFrequency == 0 ) {
    wrap_coor(fcoor, lattice, ...);
    output_dcdfile(timestep, n, fcoor, &lattice);
  }

  // Output a restart file
  if ( timestep % simParams->restartFrequency == 0 ) {
    wrap_coor(coor, lattice, ...);
    output_restart_coordinates(coor, n, timestep);
  }
  ...

  // TCL scripts
  if ( timestep == EVAL_MEASURE ) {
    wrap_coor(coor, lattice, ...);
    Node::Object()->getScript()->measure(coor);
  }
  ...
}
\end{lstlisting}


\section{HomePatch}

This is a patch of atoms that are handled by a computing node.







%\bibliographystyle{plain}
%\bibliography{simul}
\end{document}

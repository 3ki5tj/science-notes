\documentclass[12pt]{article}

\usepackage{hyperref}

\begin{document}

\title{Using FFTW3}
\date{}
\maketitle

\tableofcontents


\section{Getting started}

The FFTW library is a C library that does fast Fourier transforms.
%
This is a brief introduction on how to use it.
%
The package can be downloaded from \url{http://www.fftw.org/download.html}.
%
In Ubuntu, simply type
\begin{verbatim}
  sudo apt-get install fftw3-dev
\end{verbatim}
to install it.
%
By default, FFTW uses double precision;
so, e.g., the declaration
\texttt{fftw\_complex z;} below means \texttt{double z[2];}.



The typical use has the following steps
%
\begin{enumerate}
  \item Allocate and initialize the input and output arrays.
  \item Make an FFT plan, which specifies the input and output arrays and their sizes.
  \item Execute the plan.
\end{enumerate}

So the code looks like this
{\footnotesize
\begin{verbatim}
  fftw_complex *in = (fftw_complex *) fftw_malloc(sizeof(*in) * N);
  fftw_complex *out = (fftw_complex *) fftw_malloc(sizeof(*out) * N);
  ...
  fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
  ...
  fftw_execute(p);
\end{verbatim}
}

If you have written such a program, say \url{1d.c},
then compile it by typing
\begin{verbatim}
  gcc 1d.c -lfftw3 -lm
\end{verbatim}
and run it by typing \texttt{./a.out}.



\section{Different types of FFTs}

FFTW allows different types of fast Fourier transforms.
For example, we have 1-, 2-, 3-dimensional transformations;
the input array can be real or complex,
and it may be symmetric, etc.
%
Thus, we need to create different FFT plans for different FFTs.
%
Plans are always executed by
\texttt{fftw\_execute(p);}.

The advantage of the two-step process---creating an FFT plan first
  and then executing it
  (instead of executing FFT directly)---is, I suppose,
  to save time for multiple executions.

The list of plans can be found in:

\url{http://www.fftw.org/fftw3_doc/Basic-Interface.html}.

The mathematical meaning of different plans:

\url{http://www.fftw.org/fftw3_doc/What-FFTW-Really-Computes.html}

The tutorial covers the most common plans with example codes:

\url{http://www.fftw.org/fftw3_doc/Tutorial.html}.



\subsection{1D Fourier transform}

The one-dimensional complex Fourier transform computes
%
\begin{equation}
  Y_k = \sum_{j = 0}^{N - 1} X_j \exp(\mp 2 \pi j k i / N),
  \label{eq:fft1d}
\end{equation}
%
%


The plan is created by
\begin{verbatim}
  fftw_plan_dft_1d(N, X, Y, FFTW_FORWARD, FFTW_ESTIMATE);
\end{verbatim}
Here, \texttt{in} and \texttt{out} may be the same,
  the flags \texttt{FFTW\_FORWORD} and \texttt{FFTW\_BACKWORD}
  correspond to the minus and plus signs in (\ref{eq:fft1d}).
%
The attached code \href{1d.c}{1d.c} demonstrates this use.
%
An even shorter example \url{1dmin.c} is shown below.
Can you guess the output?
\footnotesize{
\begin{verbatim}
#include <fftw3.h>
int main(void) {
  fftw_complex a[5] = {{0,0},{1,0},{2,0},{3,0},{4,0}}; int i;
  fftw_plan p = fftw_plan_dft_1d(5, a, a, FFTW_FORWARD, FFTW_ESTIMATE);
  fftw_execute(p); fftw_execute(p); /* execute p twice */
  for (i = 0; i < 5; i++) printf("%d: %8.3f %8.3f\n", i, a[i][0], a[i][1]);
  fftw_destroy_plan(p); fftw_cleanup(); return 0;
}
\end{verbatim}
}
%



\subsection{1D real-to-complex Fourier transform}

If the input array is real, as \texttt{double in[N];}
%
The plan is created by
\begin{verbatim}
  fftw_plan_dft_r2c_1d(N, X, Y, FFTW_FORWARD, FFTW_ESTIMATE);
\end{verbatim}
%
The output array needs to hold \texttt{N/2 + 1} complex elements,
for $Y_{n - k} = Y_k^*$.
%
An example can be found in \url{1dr2c.c}.




\subsection{1D cosine and sine transforms}

Here the situations becomes complicated for cosine and sine transforms of
  a real array, for we have eight cases.
%
Fortunately they all share the same interface:
\begin{verbatim}
  fftw_plan_r2r_1d(N, X, Y, FFTW_REDFT00, FFTW_ESTIMATE);
\end{verbatim}
Here \texttt{N} is always the larger of
  the numbers of elements in \texttt{X} and \texttt{Y},
\texttt{FFTW\_REDFT00} can be replaced by one of the following options.





\subsubsection{Type-I cosine transform}
The type-I discrete cosine transform (DCT) computes
\begin{equation}
  Y_k = X_0 + (-1)^k X_{n}
  + 2 \sum_{j = 1}^{n - 1} X_j \cos(\pi j k / n)
\end{equation}
for $(X_0, X_1, \dots, X_n)$ and $(Y_0, Y_1, \dots, Y_n)$.
%
The values $Y_{n+1}, \dots, Y_{2n}$ are unnecessary because $Y_{2n - k} = Y_k$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n + 1, X, Y, FFTW_REDFT00, FFTW_ESTIMATE);
\end{verbatim}
Example code: \url{1dc1.c}.

This transform is its own inverse.
%
This means that the same transform on $(Y_0, \dots, Y_n)$,
  yields $2n$ times $(X_0, \dots, X_n)$.
%
This transform is best used to detect signals of the form of
  $X_j = \cos(\pi k j/n)$
  with an integer frequency $k$.





\subsubsection{Type-II cosine transform}
The type-II DCT computes
\begin{equation}
  Y_k = 2 \sum_{j = 0}^{n - 1} X_j \cos\big(  \pi (j + 1/2) k / n  \big)
\end{equation}
%
for $(X_0, \dots, X_{n-1})$ and $(Y_0, \dots, Y_{n-1})$.
%
The values $Y_{n}, \dots, Y_{2n}$ are unnecessary because
$Y_{2n - k} = -Y_k$
and
$Y_n = 0$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n, X, Y, FFTW_REDFT10, FFTW_ESTIMATE);
\end{verbatim}
Example code: \url{1dc2.c}.

This is the inverse of the type-III DCT.
%
This means that the application of the type-III DCT on $(Y_0, \dots, Y_{n-1})$
  gives $2n$ times $(X_0, \dots, X_{n - 1})$.
%
This transform is best used to detect signals of the form of
  $X_j = \cos(\pi k (j + 1/2)/n)$
  with an integer frequency $k$.





\subsubsection{Type-III cosine transform}
The type-III DCT computes
\begin{equation}
  Y_k = X_0 + 2 \sum_{j = 1}^{n - 1} X_j \cos(\pi j (k + 1/2) / n)
\end{equation}
%
for $(X_0, \dots, X_{n-1})$ and $(Y_0, \dots, Y_{n-1})$.
%
The values $Y_{n}, \dots, Y_{2n - 1}$ are unnecessary because
$Y_{2n - 1 - k} = Y_k$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n, X, Y, FFTW_REDFT01, FFTW_ESTIMATE);
\end{verbatim}
Example code: \url{1dc3.c}.

This is the inverse of the type-II DCT.
%
This means that the application of the type-II DCT on $(Y_0, \dots, Y_{n-1})$
  gives $2n$ times $(X_0, \dots, X_{n - 1})$.
%
This transform is best used to detect signals of the form of
  $X_j = \cos(\pi (k + 1/2) j/n)$
  with a half-integer frequency $k + 1/2$.





\subsubsection{Type-IV cosine transform}
The type-IV DCT computes
\begin{equation}
  Y_k = 2 \sum_{j = 0}^{n - 1} X_j \cos\big( \pi (j + 1/2) (k + 1/2) / n \big)
\end{equation}
%
for $(X_0, \dots, X_{n-1})$ and $(Y_0, \dots, Y_{n-1})$.
%
The values $Y_{n}, \dots, Y_{2n - 1}$ are unnecessary because
$Y_{2n - 1 - k} = -Y_k$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n, X, Y, FFTW_REDFT11, FFTW_ESTIMATE);
\end{verbatim}
Example code: \url{1dc4.c}.


This transform is its own inverse.
%
This means that the same transform on $(Y_0, \dots, Y_{n-1})$,
  yields $2n$ times $(X_0, \dots, X_{n-1})$.
This transform is best used to detect signals of the form of
  $X_j = \cos(\pi (k + 1/2) (j + 1/2) / n)$
  with a half-integer frequency $k + 1/2$.





\subsubsection{Type-I sine transform}
The type-I DST computes
\begin{equation}
  Y_k = 2 \sum_{j = 1}^{n - 1} X_j \sin\big( \pi j k / n \big)
\end{equation}
%
for $(X_0 = 0, X_1, \dots, X_{n-1})$ and $(Y_0 = 0, Y_1, \dots, Y_{n-1})$.
%
The values $Y_{n}, \dots, Y_{2n}$ are unnecessary because
$Y_{2n - k} = Y_k$ and $Y_n = 0$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n - 1, X + 1, Y + 1, FFTW_RODFT00, FFTW_ESTIMATE);
\end{verbatim}
where the offset ``+1'' skips the first zero elements.
Example code: \url{1ds1.c}.


This transform is its own inverse.
%
This means that the same transform on $(Y_0, \dots, Y_{n-1})$,
  yields $2n$ times $(X_0, \dots, X_{n-1})$.
This transform is best used to detect signals of the form of
  $X_j = \sin\big(\pi k j / n \big)$
  with an integer frequency $k$.





\subsubsection{Type-II sine transform}
The type-II DST computes
\begin{equation}
  Y_k = 2 \sum_{j = 0}^{n - 1} X_j \sin\big( \pi (j + 1/2) k / n \big)
\end{equation}
%
for $(X_0, \dots, X_{n-1})$ and $(Y_0 = 0, Y_1, \dots, Y_{n-1})$.
%
The values $Y_{n}, \dots, Y_{2n}$ are unnecessary because
$Y_{2n - k} = -Y_k$ and $Y_n = 0$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n, X, Y + 1, FFTW_RODFT10, FFTW_ESTIMATE);
\end{verbatim}
Example code: \url{1ds2.c}.


This transform is the inverse of the type-III DST.
%
This means that performing the type-III DST on $(Y_1, \dots, Y_{n-1})$,
  yields $2n$ times $(X_0, \dots, X_{n-1})$.
This transform is best used to detect signals of the form of
  $X_j = \sin\big(\pi k (j + 1/2) / n \big)$
  with an integer frequency $k$.





\subsubsection{Type-III sine transform}
The type-III DST computes
\begin{equation}
  Y_k = (-1)^k X_n
    + 2 \sum_{j = 1}^{n - 1} X_j \sin\big( \pi j (k + 1/2) / n \big)
\end{equation}
%
for $(X_0 = 0, X_1, \dots, X_{n})$ and $(Y_0, \dots, Y_{n-1})$.
%
The values $Y_{n}, \dots, Y_{2n}$ are unnecessary because
$Y_{2n - 1 - k} = -Y_k$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n, X + 1, Y, FFTW_RODFT01, FFTW_ESTIMATE);
\end{verbatim}
Example code: \url{1ds3.c}.


This transform is the inverse of the type-II DST.
%
This means that performing the type-II DST on $(Y_0, \dots, Y_{n-1})$,
  yields $2n$ times $(X_1, \dots, X_{n})$.
This transform is best used to detect signals of the form of
  $X_j = \sin\big(\pi (k + 1/2) j / n \big)$
  with a half-integer frequency $k + 1/2$.





\subsubsection{Type-IV sine transform}
The type-IV DST computes
\begin{equation}
  Y_k = (-1)^k X_n
    + 2 \sum_{j = 0}^{n - 1} X_j \sin\big( \pi (j + 1/2) (k + 1/2) / n \big)
\end{equation}
%
for $(X_0, \dots, X_{n - 1})$ and $(Y_0, \dots, Y_{n-1})$.
%
The values $Y_{n}, \dots, Y_{2n}$ are unnecessary because
$Y_{2n - 1 - k} = Y_k$.
%
And the plan is created by
\begin{verbatim}
  fftw_plan_r2r_1d(n, X, Y, FFTW_RODFT11, FFTW_ESTIMATE);
\end{verbatim}
Example code: \url{1ds4.c}.


This transform is its own inverse.
%
This means that repeating the transform on $(Y_0, \dots, Y_{n-1})$,
  yields $2n$ times $(X_1, \dots, X_{n})$.
This transform is best used to detect signals of the form of
  $X_j = \sin\big(\pi (k + 1/2) (j + 1/2) / n \big)$
  with a half-integer frequency $k + 1/2$.





\subsection{3D Fourier transform}

The three-dimensional plan is created by
\begin{verbatim}
  fftw_plan_dft_3d(N0, N1, N2, &in[0][0][0], &out[0][0][0],
    FFTW_FORWARD, FFTW_ESTIMATE);
\end{verbatim}
where the two arrays are declared as
\begin{verbatim}
  fftw_complex in[N0][N1][N2], out[N0][N1][N2];
\end{verbatim}
%
Here, we use
\texttt{\&in[0][0][0]}
to get the one-dimensional address,
which is equivalent to
\texttt{(fftw\_complex *) in}.
%
Both arrays can be dynamically allocated
to hold $\mathtt{N0} \times \mathtt{N1} \times \mathtt{N2}$
complex elements.
%
See \url{3d.c} for an example.

\end{document}

